<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Flexión</title>
    <style>
        :root {
            --primary-color: #0366d6;
            --background-color: #f6f8fa;
            --text-color: #24292e;
            --border-color: #e1e4e8;
            --card-bg: #fff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            line-height: 1.5;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 24px;
        }
        header { text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 16px; }
        header h1 { margin: 0; font-size: 24px; }
        header p { margin: 0; font-size: 14px; color: #586069; }
        .mode-selector { display: flex; justify-content: center; gap: 20px; margin-bottom: 24px; }
        .input-group h2 { font-size: 18px; margin-top: 0; margin-bottom: 12px; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }
        .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px 16px; align-items: center; }
        label { font-weight: 600; }
        input[type="number"] { width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box; font-size: 14px; }
        button { width: 100%; padding: 12px; font-size: 16px; font-weight: 600; color: #fff; background-color: var(--primary-color); border: 1px solid rgba(27, 31, 35, 0.15); border-radius: 6px; cursor: pointer; margin-top: 24px; }
        .results-group { margin-top: 24px; }
        pre { background-color: var(--background-color); padding: 16px; border-radius: 6px; border: 1px solid var(--border-color); white-space: pre-wrap; word-wrap: break-word; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; font-size: 14px; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Flexión Simple Rectangular</h1>
            <p>según CIRSOC 201-05</p>
        </header>
        <main>
            <div class="mode-selector">
                <label><input type="radio" name="mode" value="dimensionamiento" checked> Dimensionamiento</label>
                <label><input type="radio" name="mode" value="verificacion"> Verificación</label>
            </div>
            <div class="input-group">
                <h2>Materiales</h2>
                <div class="form-grid">
                    <label for="fc">f'c (MPa)</label>
                    <input type="number" id="fc" value="25">
                    <label for="fy">fy (MPa)</label>
                    <input type="number" id="fy" value="420">
                </div>
            </div>
            <div class="input-group">
                <h2>Geometría</h2>
                <div class="form-grid">
                    <label for="bw">Ancho bw (m)</label>
                    <input type="number" id="bw" value="0.25">
                    <label for="h">Altura h (m)</label>
                    <input type="number" id="h" value="0.50">
                    <label for="rec_t">Rec. Tracción (m)</label>
                    <input type="number" id="rec_t" value="0.05">
                    <label for="rec_c">Rec. Compresión (m)</label>
                    <input type="number" id="rec_c" value="0.05">
                </div>
            </div>
            <div class="input-group" id="solicitacion-group">
                <h2>Solicitación</h2>
                <div class="form-grid">
                    <label for="mu">Momento Mu (kNm)</label>
                    <input type="number" id="mu" value="150">
                </div>
            </div>
            <div class="input-group hidden" id="armaduras-group">
                <h2>Armaduras</h2>
                <div class="form-grid">
                    <label for="as">As (cm²)</label>
                    <input type="number" id="as" value="20">
                    <label for="as_prime">A's (cm²)</label>
                    <input type="number" id="as_prime" value="0">
                </div>
            </div>
            <button id="calculate-btn">Calcular</button>
            <div class="results-group">
                <h2>Resultados</h2>
                <pre id="results-output">Los resultados aparecerán aquí.</pre>
            </div>
        </main>
    </div>

    <script>
        // --- FUNCIONES DE CÁLCULO ---
        function dimensionar(fc, fy, bw, h, rec_t, d_prime, mu) {
            const d = h - rec_t;
            if (d <= d_prime) return { error: "Altura útil 'd' debe ser mayor que rec. compresión 'd_prime'." };
            const phi = 0.90, Es = 200000.0;
            const beta1 = fc <= 30 ? 0.85 : Math.max(0.65, 0.85 - 0.05 * (fc - 30) / 7);
            const f_star_c = 0.85 * fc;
            const As_min = (fc <= 31.36) ? (1.4 * bw * 100 * d * 100) / fy : (Math.sqrt(fc) * bw * 100 * d * 100) / (4 * fy);
            const mn_req = mu / phi;
            const f_star_c_kpa = f_star_c * 1000;
            const mn = mn_req / (f_star_c_kpa * bw * d ** 2);
            let ka;
            if (mn < 0 || (1 - 2 * mn) < 0) { ka = 1.1; } else { ka = 1 - Math.sqrt(1 - 2 * mn); }
            const ka_max = 0.375 * beta1;

            if (ka <= ka_max) {
                const As_calc = (f_star_c * (bw * 100) * (ka * d * 100)) / fy;
                const a_calc_mm = ((As_calc * 100) * fy) / (f_star_c * (bw * 1000));
                const a_calc_m = a_calc_mm / 1000;
                const c_calc = a_calc_m / beta1;
                const epsilon_s_calc = c_calc > 0 ? 0.003 * (d - c_calc) / c_calc : Infinity;
                let results = {
                    "Armadura de Cálculo (As)": `${As_calc.toFixed(2)} cm²`,
                    "Armadura Compresión (A's)": "0.00 cm²",
                    "--- Detalles Físicos (s/cálculo) ---": "",
                    "Eje Neutro (c)": `${c_calc.toFixed(4)} m`,
                    "Deformación Traccionada (εs)": epsilon_s_calc.toFixed(5),
                };
                if (As_calc < As_min) {
                    const As_4_3 = (4/3) * As_calc;
                    const As_final = Math.min(As_min, As_4_3);
                    results["--- Prescripción Reglamentaria ---"] = "";
                    results["As Mínima (s/norma)"] = `${As_min.toFixed(2)} cm²`;
                    results["As (4/3 del cálculo)"] = `${As_4_3.toFixed(2)} cm²`;
                    results["ARMADURA ADOPTADA (menor)"] = `${As_final.toFixed(2)} cm²`;
                }
                return results;
            } else {
                const c = 0.375 * d;
                const a = beta1 * c;
                const Mc = (f_star_c_kpa * bw * a) * (d - a / 2);
                const delta_Mn = mn_req - Mc;
                if (delta_Mn < 0) return { error: "Error: Momento excedente negativo." };
                const epsilon_prime_s = c > 0 ? 0.003 * (c - d_prime) / c : 0;
                const f_prime_s = Math.min(fy, epsilon_prime_s * Es);
                if (f_prime_s <= 0) return { error: "Armadura de compresión no trabaja." };
                const A_prime_s_m2 = delta_Mn / (f_prime_s * 1000 * (d - d_prime));
                const A_prime_s = A_prime_s_m2 * 10000;
                const Cc_N = f_star_c * (bw * 1000) * a * 1000;
                const C_prime_s_N = A_prime_s_m2 * f_prime_s * 1e6;
                const As_m2 = (Cc_N + C_prime_s_N) / (fy * 1e6);
                const As = As_m2 * 10000;
                return {
                    "Armadura Tracción (As)": `${As.toFixed(2)} cm²`,
                    "Armadura Compresión (A's)": `${A_prime_s.toFixed(2)} cm²`,
                    "--- Detalles ---": "",
                    "Eje Neutro (c)": `${c.toFixed(3)} m`,
                    "Deformación Traccionada (εs)": "0.00500",
                    "Deformación Comprimida (ε's)": epsilon_prime_s.toFixed(5),
                    "Tensión Comprimida (f's)": `${f_prime_s.toFixed(1)} MPa`,
                    "Comentario": "Requiere armadura de compresión."
                };
            }
        }
        function verificar(fc, fy, bw, h, as_cm2, as_prime_cm2, rec_t, d_prime) {
            const d = h - rec_t;
            if (d <= d_prime) return { error: "Altura útil 'd' debe ser mayor que rec. compresión 'd_prime'." };
            const Es = 200000.0, beta1 = fc <= 30 ? 0.85 : Math.max(0.65, 0.85 - 0.05 * (fc - 30) / 7), f_star_c = 0.85 * fc, epsilon_y = fy / Es;
            let As_to_use_cm2 = as_cm2, comentario_minima = "";
            const As_min = (fc <= 31.36) ? (1.4 * bw * 100 * d * 100) / fy : (Math.sqrt(fc) * bw * 100 * d * 100) / (4 * fy);
            if (as_cm2 < As_min) { As_to_use_cm2 = 0.75 * as_cm2; comentario_minima = `ADVERTENCIA: As < As,min (${As_min.toFixed(2)} cm²). Capacidad calculada con 3/4 As.`; }
            const As = As_to_use_cm2 / 10000, A_prime_s = as_prime_cm2 / 10000;
            const c_max = 0.375 * d, a_max = beta1 * c_max;
            const eps_prime_s_max = c_max > 0 ? 0.003 * (c_max - d_prime) / c_max : 0;
            const f_prime_s_max = Math.min(fy, Math.max(0, eps_prime_s_max * Es));
            const Cc_max_N = (f_star_c * 1e6) * bw * a_max, Cs_prime_max_N = A_prime_s * (f_prime_s_max * 1e6), C_total_max_N = Cc_max_N + Cs_prime_max_N;
            const T_provista_N = As * (fy * 1e6);
            let c, a, epsilon_s, f_prime_s, comentario_ductilidad;
            if (T_provista_N > C_total_max_N) {
                c = c_max; a = a_max; epsilon_s = 0.005; f_prime_s = f_prime_s_max;
                comentario_ductilidad = "ADVERTENCIA: Sección sobre-armada. Capacidad limitada por ductilidad (c=0.375d).";
            } else {
                comentario_ductilidad = "La sección cumple los límites de ductilidad.";
                const T_N_calc = As * fy;
                const c_hip1 = ((T_N_calc - (A_prime_s * fy)) / (f_star_c * bw * beta1));
                const eps_prime_s_hip1 = c_hip1 > 0 ? 0.003 * (c_hip1 - d_prime) / c_hip1 : -Infinity;
                if (eps_prime_s_hip1 >= epsilon_y && as_prime_cm2 > 0) { c = c_hip1; } else {
                    const A_coeff = f_star_c * bw * beta1, B_coeff = A_prime_s * Es * 0.003 - T_N_calc, C_coeff = -A_prime_s * Es * 0.003 * d_prime;
                    const discriminant = B_coeff ** 2 - 4 * A_coeff * C_coeff;
                    if (discriminant < 0) return { error: "Error: Discriminante negativo." };
                    c = (-B_coeff + Math.sqrt(discriminant)) / (2 * A_coeff);
                }
                a = beta1 * c;
                epsilon_s = c > 0 ? 0.003 * (d - c) / c : Infinity;
                const eps_prime_s_final = c > 0 ? 0.003 * (c - d_prime) / c : 0;
                f_prime_s = Math.min(fy, Math.max(0, eps_prime_s_final * Es));
            }
            let phi;
            if (epsilon_s >= 0.005) { phi = 0.90; } else if (epsilon_s > epsilon_y) { phi = 0.65 + 0.25 * (epsilon_s - epsilon_y) / (0.005 - epsilon_y); } else { phi = 0.65; }
            const Cc_kN = (f_star_c * 1000 * bw * a), C_prime_s_kN = (A_prime_s * f_prime_s * 1000);
            const Mn = (Cc_kN * (d - a / 2)) + (C_prime_s_kN * (d - d_prime));
            const phi_Mn = phi * Mn;
            const comentario_final = [comentario_ductilidad, comentario_minima].filter(Boolean).join(' ');
            return {
                "Capacidad de Diseño (ΦMn)": `${phi_Mn.toFixed(2)} kNm`, "--- Detalles ---": "",
                "Momento Nominal (Mn)": `${Mn.toFixed(2)} kNm`, "Factor de Reducción (Φ)": phi.toFixed(2),
                "Eje Neutro (c)": `${c.toFixed(3)} m`, "Deformación Traccionada (εs)": epsilon_s.toFixed(5),
                "Deformación Comprimida (ε's)": (f_prime_s / Es).toFixed(5), "Tensión Comprimida (f's)": `${f_prime_s.toFixed(1)} MPa`,
                "Comentario": comentario_final || "Cálculo exitoso."
            };
        }
        function displayResults(results) {
            let output = "";
            if (results.error) { output = `ERROR: ${results.error}`; } else {
                for (const key in results) { output += `${key.padEnd(35, ' ')} ${results[key]}\n`; }
            }
            resultsOutput.textContent = output;
        }
        // --- LÓGICA PRINCIPAL Y EVENTOS ---
        const modeRadios = document.querySelectorAll('input[name="mode"]');
        const solicitacionGroup = document.getElementById('solicitacion-group');
        const armadurasGroup = document.getElementById('armaduras-group');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultsOutput = document.getElementById('results-output');
        modeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                if (event.target.value === 'dimensionamiento') {
                    solicitacionGroup.classList.remove('hidden');
                    armadurasGroup.classList.add('hidden');
                } else {
                    solicitacionGroup.classList.add('hidden');
                    armadurasGroup.classList.remove('hidden');
                }
            });
        });
        calculateBtn.addEventListener('click', () => {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const fc = parseFloat(document.getElementById('fc').value), fy = parseFloat(document.getElementById('fy').value), bw = parseFloat(document.getElementById('bw').value), h = parseFloat(document.getElementById('h').value), rec_t = parseFloat(document.getElementById('rec_t').value), rec_c = parseFloat(document.getElementById('rec_c').value);
            let results;
            if (mode === 'dimensionamiento') {
                const mu = parseFloat(document.getElementById('mu').value);
                results = dimensionar(fc, fy, bw, h, rec_t, rec_c, mu);
            } else {
                const as = parseFloat(document.getElementById('as').value), as_prime = parseFloat(document.getElementById('as_prime').value);
                results = verificar(fc, fy, bw, h, as, as_prime, rec_t, rec_c);
            }
            displayResults(results);
        });
        document.querySelector('input[name="mode"]:checked').dispatchEvent(new Event('change'));
    </script>
</body>
</html>
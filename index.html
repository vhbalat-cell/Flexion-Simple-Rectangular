// Service Worker Registration
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js')
            .then(reg => console.log('Service worker registered.'))
            .catch(err => console.log('Service worker registration failed: ', err));
    });
}

// --- FUNCIONES DE CÁLCULO ---
function dimensionar(fc, fy, bw, h, rec_t, d_prime, mu) {
    const d = h - rec_t;
    if (d <= d_prime) return { error: "Altura útil 'd' debe ser mayor que rec. compresión 'd_prime'." };
    const phi = 0.90, Es = 200000.0;
    const beta1 = fc <= 30 ? 0.85 : Math.max(0.65, 0.85 - 0.05 * (fc - 30) / 7);
    const f_star_c = 0.85 * fc;
    const As_min = (fc <= 31.36) ? (1.4 * bw * 100 * d * 100) / fy : (Math.sqrt(fc) * bw * 100 * d * 100) / (4 * fy);
    const mn_req = mu / phi;
    const f_star_c_kpa = f_star_c * 1000;
    const mn = mn_req / (f_star_c_kpa * bw * d ** 2);
    let ka;
    if (mn < 0 || (1 - 2 * mn) < 0) { ka = 1.1; } else { ka = 1 - Math.sqrt(1 - 2 * mn); }
    const ka_max = 0.375 * beta1;

    if (ka <= ka_max) {
        const As_calc = (f_star_c * (bw * 100) * (ka * d * 100)) / fy;
        const a_calc_mm = ((As_calc * 100) * fy) / (f_star_c * (bw * 1000));
        const a_calc_m = a_calc_mm / 1000;
        const c_calc = a_calc_m / beta1;
        const epsilon_s_calc = c_calc > 0 ? 0.003 * (d - c_calc) / c_calc : Infinity;
        let results = {
            "Armadura de Cálculo (As)": `${As_calc.toFixed(2)} cm²`,
            "Armadura Compresión (A's)": "0.00 cm²",
            "--- Detalles Físicos (s/cálculo) ---": "",
            "Eje Neutro (c)": `${c_calc.toFixed(4)} m`,
            "Deformación Traccionada (εs)": epsilon_s_calc.toFixed(5),
        };
        if (As_calc < As_min) {
            const As_4_3 = (4/3) * As_calc;
            const As_final = Math.min(As_min, As_4_3);
            results["--- Prescripción Reglamentaria ---"] = "";
            results["As Mínima (s/norma)"] = `${As_min.toFixed(2)} cm²`;
            results["As (4/3 del cálculo)"] = `${As_4_3.toFixed(2)} cm²`;
            results["ARMADURA ADOPTADA (menor)"] = `${As_final.toFixed(2)} cm²`;
        }
        return results;
    } else {
        const c = 0.375 * d;
        const a = beta1 * c;
        const Mc = (f_star_c_kpa * bw * a) * (d - a / 2);
        const delta_Mn = mn_req - Mc;
        if (delta_Mn < 0) return { error: "Error: Momento excedente negativo." };
        const epsilon_prime_s = c > 0 ? 0.003 * (c - d_prime) / c : 0;
        const f_prime_s = Math.min(fy, epsilon_prime_s * Es);
        if (f_prime_s <= 0) return { error: "Armadura de compresión no trabaja." };
        const A_prime_s_m2 = delta_Mn / (f_prime_s * 1000 * (d - d_prime));
        const A_prime_s = A_prime_s_m2 * 10000;
        const Cc_N = f_star_c * (bw * 1000) * a * 1000;
        const C_prime_s_N = A_prime_s_m2 * f_prime_s * 1e6;
        const As_m2 = (Cc_N + C_prime_s_N) / (fy * 1e6);
        const As = As_m2 * 10000;
        return {
            "Armadura Tracción (As)": `${As.toFixed(2)} cm²`, "Armadura Compresión (A's)": `${A_prime_s.toFixed(2)} cm²`,
            "--- Detalles ---": "", "Eje Neutro (c)": `${c.toFixed(3)} m`, "Deformación Traccionada (εs)": "0.00500",
            "Deformación Comprimida (ε's)": epsilon_prime_s.toFixed(5), "Tensión Comprimida (f's)": `${f_prime_s.toFixed(1)} MPa`,
            "Comentario": "Requiere armadura de compresión."
        };
    }
}

function verificar(fc, fy, bw, h, as_cm2, as_prime_cm2, rec_t, d_prime) {
    const d = h - rec_t;
    if (d <= d_prime) return { error: "Altura útil 'd' debe ser mayor que rec. compresión 'd_prime'." };
    const Es = 200000.0, beta1 = fc <= 30 ? 0.85 : Math.max(0.65, 0.85 - 0.05 * (fc - 30) / 7), f_star_c = 0.85 * fc, epsilon_y = fy / Es;
    let As_to_use_cm2 = as_cm2, comentario_minima = "";
    const As_min = (fc <= 31.36) ? (1.4 * bw * 100 * d * 100) / fy : (Math.sqrt(fc) * bw * 100 * d * 100) / (4 * fy);
    if (as_cm2 < As_min) { As_to_use_cm2 = 0.75 * as_cm2; comentario_minima = `ADVERTENCIA: As < As,min (${As_min.toFixed(2)} cm²). Capacidad calculada con 3/4 As.`; }
    const As = As_to_use_cm2 / 10000, A_prime_s = as_prime_cm2 / 10000;
    const c_max = 0.375 * d, a_max = beta1 * c_max;
    const eps_prime_s_max = c_max > 0 ? 0.003 * (c_max - d_prime) / c_max : 0;
    const f_prime_s_max = Math.min(fy, Math.max(0, eps_prime_s_max * Es));
    const Cc_max_N = (f_star_c * 1e6) * bw * a_max, Cs_prime_max_N = A_prime_s * (f_prime_s_max * 1e6), C_total_max_N = Cc_max_N + Cs_prime_max_N;
    const T_provista_N = As * (fy * 1e6);
    let c, a, epsilon_s, f_prime_s, comentario_ductilidad;

    if (T_provista_N > C_total_max_N) {
        c = c_max; a = a_max; epsilon_s = 0.005; f_prime_s = f_prime_s_max;
        comentario_ductilidad = "ADVERTENCIA: Sección sobre-armada. Capacidad limitada por ductilidad (c=0.375d).";
    } else {
        comentario_ductilidad = "La sección cumple los límites de ductilidad.";
        let min_c = 0.0001, max_c = d;
        for (let i = 0; i < 50; i++) {
            c = (min_c + max_c) / 2;
            let eps_s = 0.003 * (d - c) / c, eps_prime_s = 0.003 * (c - d_prime) / c;
            let fs = Math.max(-fy, Math.min(fy, eps_s * Es)), f_ps = Math.max(-fy, Math.min(fy, eps_prime_s * Es));
            let T_tension = 0, C_compresion = 0;
            C_compresion += (f_star_c * 1e6) * bw * (beta1 * c);
            if (fs > 0) T_tension += As * (fs * 1e6); else C_compresion += Math.abs(As * (fs * 1e6));
            if (f_ps > 0) C_compresion += A_prime_s * (f_ps * 1e6); else T_tension += Math.abs(A_prime_s * (f_ps * 1e6));
            
            let ratio = (T_tension > 1) ? C_compresion / T_tension : (C_compresion < 1 ? 1.0 : C_compresion);
            if (ratio >= 0.999